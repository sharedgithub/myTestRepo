https://affinity-it-security.com/what-is-a-session-management-vulnerability/

# WEB APPLICATION TESTING

A vulnerability is a flaw or weakness in a system's design, implementation, operation or management that could be exploited to compromise the system's security objectives.

A threat is anything (a malicious external attacker, an internal user, a system instability, etc) that may harm the assets owned by an application (resources of value, such as the data in a database or in the file system) by exploiting a vulnerability.

Information Gathering
Configuration and Deployment Management Testing


Identity Management Testing

	- devoloping role versus permission matrix
	- manually verifying if permission are correctly provided
	- test user registration process
			-who can register, what docs are required , 
			-password polcies
			
Authentication Testing

	Testing for credentials transport means verifying that the user's authentication data are transferred via an encrypted channel to avoid being intercepted by malicious users. 
	
	The HTTPS protocol is built on TLS/SSL to encrypt the data that is transmitted and to ensure that user is being sent towards the desired site.
	
	Examine the algorithm to browse save password. it should not be in cookie or easier to intercept
	
	Testing of forgot password or password reset functionality for security flaws
	
	browser remember password should not cause a security flaw
	
	
Authorization Testing

	-privilage escaltion: there should not be a way for a  user to change his privilage from the application
	
	-to test how the authorization schema has been implemented and see if a user can acess a resuource which he is not authorized to access
	
	
Session Management Testing

	Since Hypertext Transfer Protocol (HTTP) is stateless, special provisions must be made outside of the protocol for the server to remember previous interactions with a user.  In web-applications, a “session” refers to a data-structure stored on the server that is associated with a specific user during a limited time-period.  A session is typically initiated by user authentication and is terminated when they logout (or otherwise terminate the session).  The session associated with the user is identified through a “session token” that is originally generated by the server and is delivered to the browser as a cookie.  The browser then returns the session token with subsequent requests, allowing the server to retrieve the corresponding session object and and thus maintain context with that user.
	
	
	the cookie must be protected to avoid a potential attack called “session hijacking“.
	
	Failure to use a cryptographically strong random value as the session identifier. 
	
	Failure to generate a new session identifier upon login. 
	
	Failure to invalidate the session on the server when the user chooses to logout
	
	Failure to automatically terminate the session on the server after some predefined period of inactivity. 
	
	Failure to invalidate the session when the user closes the browser without logging out.
	
Input Validation Testing
	
	Injection attacks refer to a broad class of attack vectors that allow an attacker to supply untrusted input to a program, which gets processed by an interpreter as part of a command or query which alters the course of execution of that program
	SQL,LDAP,XML,XPAth,Xquery
	
	Cross-site scripting (also known as XSS) is a web security vulnerability that allows an attacker to compromise the interactions that users havee with there browsers by injecting code

Error Handling


Cryptography
Business Logic Testing
Client Side Testing


# REST Testing



Key relevant properties of RESTful web services
	Use of HTTP methods (GET, POST, PUT and DELETE) as the primary verb for the requested operation.
	None standard parameters specifications:
	As part of the URL.
	In headers.
	Structured parameters and responses using JSON or XML in a parameter values, request body or response body. Those are required to communicate machine useful information.
	Custom authentication and session management, often utilizing custom security tokens: this is needed as machine to machine communication does not allow for login sequences.
	Lack of formal documentation. A proposed standard for describing RESTful web services called WADL was submitted by Sun Microsystems but was never officially adapted.
	
	WADL:-Web application description language


HTTPS
	Secure REST services must only provide HTTPS endpoints. This protects authentication credentials in transit, for example passwords, API keys or JSON Web Tokens. It also allows clients to authenticate the service and guarantees integrity of the transmitted data.
	
User Authentication:

API Key: 
	Just like token it is to idenify the source from where the call is made
	
	Require API keys for every request to the protected endpoint.
	Return 429 Too Many Requests HTTP response code if requests are coming in too quickly.
	Revoke the API key if the client violates the usage agreement.
	Do not rely exclusively on API keys to protect sensitive, critical or high-value resources.

Restrict HTTP methods
	Apply a whitelist of permitted HTTP Methods e.g. GET, POST, PUT.
	Reject all requests not matching the whitelist with HTTP response code 405 Method not allowed.
	//patch put trace methods can create problemets
	
Input Validation
	it is about validation of input data structure. It should be in a proper format and currect range of values ie Validate input: length / range / format and type.
	Constrain string inputs with regexps.
	Reject unexpected/illegal content.
	Define an appropriate request size limit and reject requests exceeding the limit with HTTP response status 413 Request Entity Too Large.

Error Handling
	Respond with generic error messages - avoid revealing details of the failure unnecessarily.
	Do not pass technical details (e.g. call stacks or other internal hints) to the client.
	
Audit logs
	writing logs for security related events 
	Consider logging token validation errors in order to detect attacks.

Security headers 
	To make sure the content of a given resources is interpreted correctly by the browser, the server should always send the Content-Type header
	
CORS
	Cross-Origin Resource Sharing (CORS) is a W3C standard to flexibly specify what cross-domain requests are permitted. By delivering appropriate CORS Headers your REST API signals to the browser which domains, AKA origins, are allowed to make JavaScript calls to the REST service.

	Disable CORS headers if cross-domain calls are not supported/expected.
	
Sensitive information in HTTP requests
	RESTful web services should be careful to prevent leaking credentials. Passwords, security tokens, and API keys should not appear in the URL, as this can be captured in web server logs, which makes them intrinsically valuable.

	In POST/PUT requests sensitive data should be transferred in the request body or request headers.
	In GET requests sensitive data should be transferred in an HTTP Header.
	
Validate content types
	A REST request or response body should match the intended content type in the header. Otherwise this could cause misinterpretation at the consumer/producer side and lead to code injection/execution.
	Reject requests containing unexpected or missing content type headers with HTTP response status 406 Unacceptable or 415 Unsupported Media Type.
	Reject the request (ideally with a 406 Not Acceptable response) if the Accept header does not specifically contain one of the allowable types.
	
HTTP Return Code: Appropriate return code must be used 

Code	Message	Decription
200	OK	Response to a successful REST API action. The HTTP method can be GET, POST, PUT, PATCH or DELETE.
201	Created	The request has been fulfilled and resource created. A URI for the created resource is returned in the Location header.
202	Accepted	The request has been accepted for processing, but processing is not yet complete.
301	Moved Permanently	Permanent redirection.
304	Not Modified	Caching related response that returned when the client has the same copy of the resource as the server.
307	Temporary Redirect	Temporary redirection of resource.
400	Bad Request	The request is malformed, such as message body format error.
401	Unauthorized	Wrong or no authentication ID/password provided.
403	Forbidden	It's used when the authentication succeeded but authenticated user doesn't have permission to the request resource.
404	Not Found	When a non-existent resource is requested.
405	Method Not Acceptable	The error for an unexpected HTTP method. For example, the REST API is expecting HTTP GET, but HTTP PUT is used.
406	Unacceptable	The client presented a content type in the Accept header which is not supported by the server API.
413	Payload too large	Use it to signal that the request size exceeded the given limit e.g. regarding file uploads.
415	Unsupported Media Type	The requested content type is not supported by the REST service.
429	Too Many Requests	The error is used when there may be DOS attack detected or the request is rejected due to rate limiting.
500	Internal Server Error	An unexpected condition prevented the server from fulfilling the request. Be aware that the response should not reveal internal information that helps an attacker, e.g. detailed error messages or stack traces.
501	Not Implemented	The REST service does not implement the requested operation yet.
503	Service Unavailable	The REST service is temporarily unable to process the request. Used to inform the client it should retry at a later time.
